---
title: "Hands-on_Ex03_1"
author: "Cathy Chu"
date-modified: "last-modified" 
execute:
  echo: true 
  eval: true 
  warning: false 
  freeze: true
---

## **Programming Interactive Data Visualisation with R**

## [3.1]{style="color:skyblue"} Learning Outcome

In this hands-on exercise, you will learn how to create interactive data cisualisation by using functions provided by **ggiraph** and **plotlyr** packages.

## [3.2]{style="color:skyblue"} Getting Started

First, write a code chunk to check, install and launch t he following R packages:

-   [**ggiraph**](https://davidgohel.github.io/ggiraph/) for making 'ggplot' graphics interactive.
-   [**plotly**](https://plotly.com/r/), R library for plotting interactive statistical graphs
-   [**DT**](https://rstudio.github.io/DT/) provides an R interface to the JavaScript library [DataTables](https://datatables.net/) that create interactive table on html page.
-   [**tidyverse**](https://www.tidyverse.org/)**,** a family of modern R packages specially designed to support data science, analysis and communication task including creating static statistical graphs.
-   [**patchwork**](https://patchwork.data-imaginist.com/) for combining multiple ggplot2 graphs into one figure.

🔑 The code chunk below will be used to accomplish the task.

```{r, echo=FALSE}
pacman::p_load(ggiraph, plotly,
               patchwork, DT, tidyverse)
```

## [3.3]{style="color:skyblue"} Importing Data

In this section, E*xam_data.csv* provided will be used. Using [*read_csv()*](https://readr.tidyverse.org/reference/read_delim.html) of **readr** package, import *Exam_data.csv* into R.

The code chunk below `read_csv()` of **readr** package is used to import Exam_data.csv data file into R and save it as an tibble data frame called `exam_data`.

```{r}
library(readr)
exam_data <- read_csv("data/Exam_data.csv")
```

## [3.4]{style="color:skyblue"} Interactive Data Visualisation - ggiraph methods

[ggiraph](https://davidgohel.github.io/ggiraph/) ![](images/logo.png){width="50"} is an htmlwidget and a ggplot2 extension. It allows ggplot graphics to be interactive.

Interactive is made with [ggplot geometries](https://davidgohel.github.io/ggiraph/reference/#section-interactive-geometries) that can understand three arguments:

-   **Tooltip:** a column of data-sets that contain tooltips to be displayed when the mouse is over elements.
-   **Onclick:** a column of data-sets that contain a JavaScript function to be executed when elements are clicked.
-   **Data_id:** a column of data-sets that contain an id to be associated with elements.

::: column-margin
🎯 Onclick, Data_id
:::

If it is used within a shiny application, elements associated with an id(data_id) can be selected and manipulated on client and server sides. Refer to this [article](https://davidgohel.github.io/ggiraph/articles/offcran/shiny.html) for more detail explanation.

::: column-margin
❗[article](https://davidgohel.github.io/ggiraph/articles/offcran/shiny.html) not found.
:::

### [3.4.1]{style="color:skyblue"} Tooltip effect with *tooltip* aesthetic

Below shows a typical code chunk to plot an interactive statistical graph by using **ggiraph** package. Notice that the code chunk consists of two parts. First, a ggplot object will be created. Next, [`girafe()`](https://davidgohel.github.io/ggiraph/reference/girafe.html) of **ggiraph** will be used to create an interactive svg object.

```{r}
p <- ggplot(data=exam_data,
            aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = ID),
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  scale_y_continuous(NULL,
                     breaks = NULL
  )
girafe(
  ggobj = p,
  width_svg = 6,
  height_svg = 6*0.618
)
```

Notice that two steps are involved.

First, an interactive vrsion of ggplot2 geom (i.e. [geom_dotplot_interactive()](https://davidgohel.github.io/ggiraph/reference/geom_dotplot_interactive.html)) will be used to create the basic graph. Then, [girafe()](https://davidgohel.github.io/ggiraph/reference/girafe.html) will be used to generate an svg object to be displayed on an html page.

## [3.5]{style="color:skyblue"} Interactivity

By hovering the mouse pointer on an data point of interest, the student's ID will be displayed.

```{r echo=FALSE}
p <- ggplot(data=exam_data,
            aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = ID),
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot",
    fill = "pink",
    color = "gray") +
  scale_y_continuous(NULL,
                     breaks = NULL
  )
girafe(
  ggobj = p,
  width_svg = 6,
  height_svg = 6*0.618
)
```

### [3.5.1]{style="color:skyblue"} Displaying multiple information on tooltip

🔑 The content of the tooltip can be customised by including a list object as shown in the code chunk below.

```{r}
exam_data$tooltip <- c(paste0(
  "Name = ", exam_data$ID,
  "\n Class =", exam_data$CLASS))

p <- ggplot(data=exam_data,
            aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = exam_data$tooltip),
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  scale_y_continuous(NULL,
                     breaks=NULL)

girafe(
  ggobj = p,
  width_svg = 8,
  height_svg = 8*0.618
)

```

The first three lines of codes in the code chunk create a new field called *tooltip*. At the same time, it populates text in ID and CLASS fields into the newly created field. Next, this newly created field is used as tooltip field as shown in the code of line 7.

## [3.6]{style="color:skyblue"} Interactivity - customisation

By hovering the mouse pointer on a data point of interest, the student's ID and CLASS are displayed.

```{r, echo = FALSE}
exam_data$tooltip <- c(paste0(
  "Name = ", exam_data$ID,
  "\n Class =", exam_data$CLASS))

p <- ggplot(data=exam_data,
            aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = exam_data$tooltip),
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot",
    fill = "skyblue",
    color = "gray") +
  scale_y_continuous(NULL,
                     breaks=NULL)

girafe(
  ggobj = p,
  width_svg = 8,
  height_svg = 8*0.618
)

```

### [3.7.1]{style="color:skyblue"} Customising Tooltip style

🔑 Code chunk below uses [`opts_tooltip()`](https://davidgohel.github.io/ggiraph/reference/opts_tooltip.html) of ggiraph to customise tooltip rendering by adding css declarations.

``` r
tooltip_css <- "background-color: pink;  #<<
front-style:bold; color: #fff;" #<<

p <- ggplot(data = exam_data,
            aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = ID),
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  scale_y_continuous(NULL,
                     breaks = NULL)

girafe(
  ggobj = p,
  width_svg = 6,
  height_svg = 6*0.618,
  options = list(    #<<
    opts_tooltip(    #<<
      css = tooltip_css)) #<<
)
```

Notice that the background colour of the tooltip is **pink** and the font colour is white and bold.

```{r, echo=FALSE}
tooltip_css <- "background-color: pink;  #<<
front-style:bold; color: #fff;" #<<

p <- ggplot(data = exam_data,
            aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = ID),
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  scale_y_continuous(NULL,
                     breaks = NULL)

girafe(
  ggobj = p,
  width_svg = 6,
  height_svg = 6*0.618,
  options = list(    #<<
    opts_tooltip(    #<<
      css = tooltip_css)) #<<
)
```

::: column-margin
❓ How to change tooltip fonts?

❓ Text to appear between code chunk and charts
:::

Refer to [Customizing girafe objects](https://davidgohel.github.io/ggiraph/articles/offcran/customizing.html) to learn more about how to customise ggriaph objects. *(link is not working as of Jan 16 2025)*

### [3.6.2]{style="color:skyblue"} Displaying statistics on tooltip

🔑 Code chunk below shows an advanced way to customise tooltip. In this example, a function is used to compute 90% confident interval of the mean. The derived statistics are then displayed in the tooltip.

```{r}
tooltip <- function(y, ymax, accuracy = .01) {
  mean <- scales::number(y, accuracy = accuracy)
  sem <- scales::number(ymax - y, accuracy = accuracy)
  paste("Mean maths scores: ", mean, "+/-", sem)
}

gg_point <- ggplot(data=exam_data,
                  aes(x = RACE),
) +
  stat_summary(aes(y = MATHS,
                   tooltip = after_stat(
                     tooltip(y, ymax))),
               fun.data = mean_se,
               geom = GeomInteractiveCol,
               fill = "light blue"
              ) + 
              stat_summary(aes(y = MATHS),
                fun.data = mean_se,
                geom = "errorbar", width = 0.2, size = 0.2
              )
girafe(ggobj = gg_point,
       width_svg = 8,
       height_svg = 8*0.618)
```

### [3.6.3]{style="color:skyblue"} Hover effect with *data_id* aesthetic

🔑 Code chunk below shows the second interactive feature of ggiraph, namely `data_id`.

``` r
p <- ggplot(data=exam_data,
            aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(data_id = CLASS),
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  scale_y_continuous(NULL,
                     breaks = NULL
  )

girafe(
  ggobj = p,
  width_svg = 6,
  height_svg = 6*0.618
)
```

Interactivity: Elements associated with a *data_id* (i.e. CLASS) will be highlighted upon mouse over.

```{r, echo=FALSE}
p <- ggplot(data=exam_data,
            aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(data_id = CLASS),
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  scale_y_continuous(NULL,
                     breaks = NULL
  )

girafe(
  ggobj = p,
  width_svg = 6,
  height_svg = 6*0.618
)
```

::: callout-note
Note that the default value of the hover css is *hover_css = "fill:orange;"*
:::

### [3.6.4]{style="color:skyblue"} Styling hover effect

In the code chunk below, css codes are used to change the highlighting effect.

```{r}
p <- ggplot(data=exam_data,
            aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(data_id=CLASS),
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  scale_y_continuous(NULL,
                     breaks = NULL
  )

girafe(
  ggobj = p,
  width_svg = 6,
  height_svg = 6*0.618,
  options = list(
    opts_hover(css = "fill:#202020;"),
    opts_hover_inv(css = "opacity:0.2;")
  )
)
```

Interactivity: Elements associated with a *data_id (i.e. CLASS)* will be highlighted upon mouse hover.

::: callout-note
Different from previous example, in this example the css customisation request are encoded directly.
:::

### [3.6.5]{style="color:skyblue"} Combining tooltip and hover effect

🔑 There are time when we want to combine tooltip and hover effect on the interactive statistical graph as shown in the code chunk below.

```{r}
p <- ggplot(data=exam_data,
            aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = CLASS, #tooltip here
        data_id = CLASS),
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  scale_y_continuous(NULL,
                     breaks = NULL)

girafe(
  ggobj = p,
  width_svg = 6,
  height_svg = 6*0.618,
  options = list(
    opts_hover(css = "fill: #2020202;"),
    opts_hover_inv(css = "opacity:0.2")
  )
)
```

Interactivity: Elements associated with a *data_id* (i.e. CLASS) will be highlighted upon mouse over. At the same time, the tooltip will show the CLASS.

### [3.6.6]{style="color:skyblue"} Click effect with **onclick**

`onclick` argument of ggiraph provides hotlink interactivity on the web.

🔑 The code chunk below shown an example of `onclick`.

```{r}
exam_data$onclick <- sprintf("window.open(\"%s%s\")",
"https://www.moe.gov.sg/schoolfinder?journey=Primary%20school",
as.character(exam_data$ID)) #onclic link here

p <- ggplot(data=exam_data,
            aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(onclick = onclick),
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  scale_y_continuous(NULL,
                     breaks = NULL
  )
girafe(
  ggobj = p,
  width_svg = 6,
  height_svg = 6*0.618
)
```

::: callout-warning
Note that click actions must be a string column in the dataset containing valid JavaScript instructions.
:::

::: column-margin
❓ string column in the dataset
:::

### [3.6.7]{style="color:skyblue"} Coordinated Multiple Views with ggiraph

Coordinated multiple views methods has been implemented in the data visualisation below.

```{r, echo=FALSE}
p1 <- ggplot(data=exam_data,
             aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(data_id = ID,),
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  coord_cartesian(xlim = c(0,100)) +
  scale_y_continuous(NULL,
                     breaks = NULL)

p2 <- ggplot(data=exam_data,
             aes(x = ENGLISH)) +
  geom_dotplot_interactive(
    aes(data_id = ID),
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  coord_cartesian(xlim = c(0,100)) + #patchwork here
  scale_y_continuous(NULL,
                     breaks = NULL)

girafe(code = print(p1 + p2),
       width_svg = 6,
       height_svg = 3,
       options = list(
         opts_hover(css = "fill:#202020;"),
         opts_hover_inv(css = "opacity:0.2;")
       ))

```

🐳 Note that when a data point of one of the dotplot is selected, the corresponding data point ID on the second data visualisation will be highlighted too.

In order to build a coordinated multiple views as shown in the example above, the following programming strategy will be used:

1.  Appropriate interactive functions of **ggiraph** will be used to create the multiple views.
2.  *patchwork* function of [patchwork](https://patchwork.data-imaginist.com/) package will be used inside girafe function to create the interactive coordinated multiple views.

::: column-margin
🦄 The goal of `patchwork` is to make it ridiculously simple to combine separate ggplots into the same graphic. As such it tries to solve the same problem as [`gridExtra::grid.arrange()`](https://rdrr.io/pkg/gridExtra/man/arrangeGrob.html) and `cowplot::plot_grid` but using an API that incites exploration and iteration, and scales to arbitrarily complex layouts.
:::

``` r
p1 <- ggplot(data=exam_data,
             aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(data_id = ID,),
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  coord_cartesian(xlim = c(0,100)) +
  scale_y_continuous(NULL,
                     breaks = NULL)

p2 <- ggplot(data=exam_data,
             aes(x = ENGLISH)) +
  geom_dotplot_interactive(
    aes(data_id = ID),
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  coord_cartesian(xlim = c(0,100)) + #patchwork here
  scale_y_continuous(NULL,
                     breaks = NULL)

girafe(code = print(p1 + p2),
       width_svg = 6,
       height_svg = 3,
       options = list(
         opts_hover(css = "fill:#202020;"),
         opts_hover_inv(css = "opacity:0.2;")
       ))
```

The *data_id* aesthetic is critical to link observations between plots and the tooltip aesthetic is optional but nice to have when mouse over a point.

## [3.7]{style="color:skyblue"} Interactive Data Visualisation - plotly methods!

Plotly's R graphing library create interactive web graphics from **ggplot2** graphs and/or a custom interface to the (MIT-licensed) JavaScript library [plotly.js](https://plotly.com/javascript/) inspired by the grammar of graphics. Different from other plotly platform, plot.R is free and open source.

![](images/3.7%20plotly.jpg)

There are two ways to create interactive graph by using plotly, they are:

-   by using *`plot_ly()`*, and
-   by using *`ggplotly()`*

### [3.7.1]{style="color:skyblue"} Creating an interactive scatter plot: plot_ly() method

### [3.7.2]{style="color:skyblue"} Working with visual variable: plot_ly() method

### [3.7.3]{style="color:skyblue"} Creating an interactive scatter plot: ggplotly() method

### [3.7.4]{style="color:skyblue"} Coordinated multiple views with plotly

## [3.8]{style="color:skyblue"} Interactive Data Visualisation - crosstalk methods!

## [3.9]{style="color:skyblue"} Reference
